
For all transacions: remove legacy from transaction_t.

License this library. Read about here: http://www.gnu.org/licenses/gpl-howto.ru.html.

Написать тесты для holding'ов и для file_record'ов, по аналогии с тестами для coils.

Добавить очередь в client_t. И если он будет работать в асинхронном режиме,
то использовать эту очередь.

Разобраться с именами функций, регистров, катушек, файлов и прочим.

Сделать клеиентскую и серверную функции 0x17. (Read/Write multiple registers)

Сделать серверную функцию 0x18. (Read FIFO)

Разработать прокси для сервера, как в rmodbus.
Заметки по прокси:
Для чтения чего-либо из сервера транзакция должна быть синхронной, потому, что:
функция чтения должна вернуть какое-то значение. А для функций записи надо сделать
так, чтобы синхронность можно было отключить. Если клиент асинхронный (с очередью или без), 
то придётся блокировать поток до тех пор, пока не придёт ответ.
Для прокси-регистров и прокси-катушек и прочих прокси написать итераторы по регистрам, катушкам и пр.

Сделать широковещательные запросы в клиенте.
Сделать обработку широковещательных запросов на сервере.

Для функций Read/Write File Record необходимо
сделать ограничение на file-number от 0x0001 до 0xFFFF. Но, пока
в наших модулях используется это пооле именно со значением 0x0000, этого делать
нельзя. Короче: сделать, но пока закомментить.

Переименовать функции, структуры и т.п. так, чтобы они начинались с префикса emb_ (emodbus)

Постараться сделать так, чтобы стек был как можно меньше. Т.к. флешки у контроллеров
значительно больше, чем оперативки.

Может быть убрать приёмный буфер из нижнего уровня клиента, а пользоваться только тем, который 
приходит из запроса на транзакцию ?

Когда буду писать TCP, то посмотреть, как это уже сделано тут:
https://github.com/rscada/libmodbus

Сделать нормальный bit_vector для coils.
